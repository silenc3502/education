#include <stdio.h>

int main(void)
{
	/* unsigned 가 붙으면 무조건 양수
	   없으면 음수와 양수가 양립
	   char 는 1 byte = 8 bit
	   1 bit 가 표현할 수 있는
	   개수는 0, 1 로 2 개
	   2 bit 가 표현할 수 있는
	   개수는 00, 01, 10, 11 로 4 개
	   3 bit 가 표현할 수 있는
	   개수는 000, 001, 010, 011,
	   100, 101, 110, 111 로 8 
	   그렇다면 8 bit 가 표현할 수 있는건 256 개
	   문제는 음수와 양수를
	   어떻게 표현할 것인가에 해당함
	   부호 비트를 하나 만들었고
	   부호 비트는 최상위에 배치됨
	   부호 비트가 1 이면 음수, 0 이면 양수
	   1 + (-1) = 0 이 되는 시스템을 설계하면 됨
	   8 비트 기준으로 1 을 표현해보자!

	     0000 0001   (+1)
	   + 1000 0001   (-1)
	   ------------------
	     1000 0010   (??)

	   원래 0 이 나와야 하는데
	   이상한 값이 나오고 있음
	   즉 생각한 방식이 잘못되었음을 알 수 있다.

	     0000 0001   (+1)
	   + 1111 1111   (-1)
	   ------------------
	   1 0000 0000   (0)

	   바꾸는 패턴이 첫 번째 1 을 찾고
	   그 이후의 패턴은 유지한다.
	   나머지는 전부 반전(not)시키면 됨

              11
	     0000 1010   (+10)
		 1111 0110   (-10)
	   ------------------
	   1 0000 0000   (0)

	   현재 예에서 not(10) 을
	   계산하는 방법을 살펴보도록 하자!

	     0000 1010   (+10)
		 1111 0101   (~10) = ? = -11

	   위의 패턴을 활용한 음수 변환법을
	   음수에 적용하면 양수가 나올 것이다.

		 1111 0101   (~10) = ? = -11
	     0000 1011   (+11)
	   ------------------
	   1 0000 0000   (0)

	   이번에는 unsigned 가 붙은 케이스를 살펴보자!

	   0000 1010   (10)
       1111 0101   (245)
	   0 ~ 255 (256 개)

       즉 unsigned 는 signed 에 비해
	   not 계산이 비교적 쉬움

	   ex) ~23

	   0001 0111   (+23)
	   1110 1000   (~23) = -24
       0001 1000   (+24) */
	unsigned char num1 = 10;
	char num2 = 10;

	// ~ 은 비트 연산자 not
	printf("not num = %u\n", (unsigned char)~num1);
	printf("not num = %d\n", (char)~num2);

	return 0;
}







